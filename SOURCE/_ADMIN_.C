#include"_ADMIN_.H"

/*****************************************************************
MODULE:管理员主菜单
*****************************************************************/
void main_admin(int *page,unsigned long *ID){
    int tag=ACTIVE_ADMIN_NULL;
    ADMIN_BUTTONS AdminButtons[9];
    define_admin_buttons(AdminButtons, STRUCT_LENGTH(AdminButtons)); // 定义按钮

    clrmous(MouseX, MouseY);
    drawgraph_admin_menu(); // 初始化界面
    mouseinit();

    if(debug_mode == 1) display_memory_usage(400, 10); // 显示调试参数 

    while(*page == MAIN_ADMIN){
        admin_flush_buttons(&tag,STRUCT_LENGTH(AdminButtons),AdminButtons);
        admin_handle_buttons_event(page);
        //应该在传入AdminButtons前计算其长度，传入函数后，使用sizeof计算其长度则会退化为指针长度，导致功能失效
        newmouse(&MouseX, &MouseY, &press);

        delay(25);
    }
    
}

/*****************************************************************
MODULE:管理员车辆管理模块
*****************************************************************/
void admin_manage_bike_module(int *page, unsigned long *ID, LINKLIST *LIST, char *file_path, char *list_mode){
    int mode = 0; // 搜索模式，列出已处理清单或待处理清单，主动清除该页面时重设为0（默认列出待处理清单）
    // static int visited=0; // 是否进入乐该页面，主动清除该页面时重设为0
    char search_str[20]; // 搜索框输入信息储存
    unsigned long selected_id = 0;
    unsigned long id_list[8] = {0,0,0,0,0,0,0,0}; // 记录当前显示的列表每行对应的ID
    int tag = ACTIVE_ADMIN_NULL;
    int temp_page = *page; // 记录当前页面
    ADMIN_BUTTONS AdminButtons[19];
    FILE *fp_EBIKE_INFO_read = fopen(file_path, "rb+");
    if (!fp_EBIKE_INFO_read)
        exit(1);

    define_admin_buttons(AdminButtons, STRUCT_LENGTH(AdminButtons)); // 定义按钮

    fseek(fp_EBIKE_INFO_read, 0, SEEK_SET);
    drawgraph_admin_menu();
    drawgraph_admin_feature(*page);

    // 列出数据
    admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp_EBIKE_INFO_read, "ebike_manage", 
                    list_mode, mode, LIST_PAGEDOWN, LIST_CLEAR_CONTINUE, "\0", "\0");

    if (debug_mode == 1)
        display_memory_usage(400, 10); // 显示调试参数

    while (*page == temp_page)
    {
        admin_flush_buttons(&tag, STRUCT_LENGTH(AdminButtons), AdminButtons);
        admin_handle_buttons_event(page);
        handle_list_select_line_admin(id_list, &selected_id, LIST_LIMIT, LIST_INTERVAL);
        newmouse(&MouseX, &MouseY, &press);

        admin_handle_manage_feature_event(LIST, page, search_str, id_list, fp_EBIKE_INFO_read, &mode, selected_id); // 处理点击事件

        delay(25);
    }

    admin_list_info(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, LIST_CLEAR, NULL, NULL);
    Input_Bar(NULL, NULL, NULL, NULL, NULL, INPUTBAR_CLEAR, NULL);
    fclose(fp_EBIKE_INFO_read);
    return;
}

/*****************************************************************
MODULE:查看管理员信息
*****************************************************************/
void admin_info(int *page, unsigned long *ID){
    int tag = ACTIVE_ADMIN_NULL;
    ADMIN_BUTTONS AdminButtons[9];
    define_admin_buttons(AdminButtons, STRUCT_LENGTH(AdminButtons)); // 定义按钮
    clrmous(MouseX, MouseY);
    drawgraph_admin_menu(); // 初始化界面

    if (debug_mode == 1)
        display_memory_usage(400, 10); // 显示调试参数

    while(*page == ADMIN_INFO){
        admin_flush_buttons(&tag,STRUCT_LENGTH(AdminButtons),AdminButtons);
        admin_handle_buttons_event(page);
        newmouse(&MouseX, &MouseY, &press);

        drawgraph_admin_info(*ID); // 显示管理员信息

        delay(25);
    }
}

/*****************************************************************
MODULE:数据一览界面
*****************************************************************/
void admin_database(int *page, unsigned long *ID , LINKLIST *LIST){
    int tag = ACTIVE_ADMIN_NULL;
    int flag = ADMIN_DATABASE_NULL; // 数据一览视图代号
    unsigned long selected_id = 0;
    unsigned long id_list[8] = {0,0,0,0,0,0,0,0}; // 记录当前显示的列表每行对应的ID
    char search_str[20] = "\0"; // 搜索框输入信息储存
    ADMIN_BUTTONS AdminButtons[19];
    FILE *fp_USER_LOGIN_DATA_read = fopen("DATA\\USER.DAT", "rb+"); // 打开用户登录数据文件
    if (!fp_USER_LOGIN_DATA_read){
        getch(), exit(1);
    }
    // 列出车辆信息时，通过链表获取数据，因此不定义文件指针

    define_admin_buttons(AdminButtons, STRUCT_LENGTH(AdminButtons)); // 定义按钮 
    clrmous(MouseX, MouseY);
    drawgraph_admin_menu(); // 绘制界面
    drawgraph_admin_database();

    if (debug_mode == 1)
        display_memory_usage(400, 10); // 显示调试参数

    while (*page == ADMIN_DATABASE){
        admin_flush_buttons(&tag, STRUCT_LENGTH(AdminButtons), AdminButtons);
        admin_handle_buttons_event(page);
        admin_handle_database_event(LIST, &flag, page, id_list, fp_USER_LOGIN_DATA_read,search_str); // 处理点击事件
        handle_list_select_line_admin(id_list, &selected_id, LIST_LIMIT, LIST_INTERVAL);

        newmouse(&MouseX, &MouseY, &press);

        delay(25);
    }

    admin_list_info(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, LIST_CLEAR, NULL, NULL); // 清除列表
    Input_Bar(NULL, NULL, NULL, NULL, NULL, INPUTBAR_CLEAR, NULL);
    fclose(fp_USER_LOGIN_DATA_read);
}

void admin_modify_data(int *page, unsigned long *ID, LINKLIST *LIST, char *file_path, char *list_mode){
    // void far *sv_bk = farmalloc(imagesize(0, 0, 639, 479)); // 保存图像
    // getimage(0, 0, 639, 479, sv_bk); // 保存图像

    setwritemode(XOR_PUT);                      // 设置写入模式为异或

}

/*****************************************************************
MODULE:绘制画面、刷新画面和处理鼠标点击的画图函数
*****************************************************************/

void drawgraph_admin_menu(void)
{
    int i;

    /*** 绘制菜单 ***/
    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(ADMIN_MENU_X1, ADMIN_MENU_Y1, ADMIN_MENU_X2, ADMIN_MENU_Y2);
    setcolor(BLUE);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    rectangle(ADMIN_MENU_X1 + 2, ADMIN_MENU_Y1 + 2, ADMIN_MENU_X2 - 2, ADMIN_MENU_Y2 - 2);
    setcolor(MY_BLACK);
    setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
    rectangle(ADMIN_MENU_X1 + 2, ADMIN_MENU_Y1 + 2, ADMIN_MENU_X2 - 2, ADMIN_MENU_Y2 - 2);

    /*** 绘制交互界面（暂为空白） ***/
    setfillstyle(SOLID_FILL, BLUE);
    bar(ADMIN_INTERFACE_X1, ADMIN_INTERFACE_Y1, ADMIN_INTERFACE_X2, ADMIN_INTERFACE_Y2);
    setcolor(CYAN);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    rectangle(ADMIN_INTERFACE_X1 + 2, ADMIN_INTERFACE_Y1 + 2, ADMIN_INTERFACE_X2 - 2, ADMIN_INTERFACE_Y2 - 2);
    setcolor(MY_LIGHTGRAY);
    setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
    rectangle(ADMIN_INTERFACE_X1 + 2, ADMIN_INTERFACE_Y1 + 2, ADMIN_INTERFACE_X2 - 2, ADMIN_INTERFACE_Y2 - 2);

    // /*** 绘制交互界面B（暂为空白） ***/
    // setfillstyle(SOLID_FILL, BLUE);
    // bar(INTERFACE_B_X1, INTERFACE_B_Y1, INTERFACE_B_X2, INTERFACE_B_Y2);
    // setcolor(CYAN);
    // setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    // rectangle(INTERFACE_B_X1+2, INTERFACE_B_Y1+2, INTERFACE_B_X2-2, INTERFACE_B_Y2-2);
    // setcolor(MY_LIGHTGRAY);
    // setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
    // rectangle(INTERFACE_B_X1+2, INTERFACE_B_Y1+2, INTERFACE_B_X2-2, INTERFACE_B_Y2-2);

    setcolor(MY_WHITE);
    for (i = 0; i < 7; i++)
    {
        setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
        line(ADMIN_MENU_X1 + 10, ADMIN_MENU_Y1 + 45 + i * 40, ADMIN_MENU_X2 - 10, ADMIN_MENU_Y1 + 45 + i * 40);
        setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
        line(ADMIN_MENU_X1 + 6, ADMIN_MENU_Y1 + 45 + i * 40, ADMIN_MENU_X2 - 6, ADMIN_MENU_Y1 + 45 + i * 40);
        delay(10);
    }
    puthz(ADMIN_MENU_X1 + 25, ADMIN_MENU_Y1 + 25, "车辆注册", 16, 18, MY_WHITE);  // 输出文本
    puthz(ADMIN_MENU_X1 + 25, ADMIN_MENU_Y1 + 65, "上牌管理", 16, 18, MY_WHITE);  // 输出文本
    puthz(ADMIN_MENU_X1 + 25, ADMIN_MENU_Y1 + 105, "车辆报废", 16, 18, MY_WHITE); // 输出文本
    puthz(ADMIN_MENU_X1 + 25, ADMIN_MENU_Y1 + 145, "违规车辆", 16, 18, MY_WHITE); // 输出文本
    puthz(ADMIN_MENU_X1 + 25, ADMIN_MENU_Y1 + 185, "车辆年审", 16, 18, MY_WHITE); // 输出文本
    puthz(ADMIN_MENU_X1 + 25, ADMIN_MENU_Y1 + 225, "数据一览", 16, 18, MY_WHITE); // 输出文本
    puthz(ADMIN_MENU_X1 + 25, ADMIN_MENU_Y1 + 265, "信息中心", 16, 18, MY_WHITE); // 输出文本

    setcolor(MY_WHITE);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    line(ADMIN_MENU_X1 + 6, ADMIN_MENU_Y2 - 170, ADMIN_MENU_X1 + 6, ADMIN_MENU_Y2 - 144); // 绘制直线
    setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
    bar(ADMIN_MENU_X1 + 8, ADMIN_MENU_Y2 - 170, ADMIN_MENU_X1 + 90, ADMIN_MENU_Y2 - 144); // 绘制填充矩形

    setcolor(MY_GREEN);
    settextstyle(DEFAULT_FONT, HORIZ_DIR, 1);
    outtextxy(ADMIN_MENU_X1 + 10, ADMIN_MENU_Y2 - 170, "ELECTRONIC"); // 输出文本
    outtextxy(ADMIN_MENU_X1 + 10, ADMIN_MENU_Y2 - 160, "BIKE");      // 输出文本
    outtextxy(ADMIN_MENU_X1 + 10, ADMIN_MENU_Y2 - 150, "SYSTEM"); // 输出文本

    clear_person(ADMIN_INFO_X1, ADMIN_INFO_Y1, ADMIN_INFO_X2, ADMIN_INFO_Y2);

    clear_exit(ADMIN_EXIT_X1, ADMIN_EXIT_Y1, ADMIN_EXIT_X2, ADMIN_EXIT_Y2);
}

void drawgraph_admin_feature(int page)
{
    switch (page)
    {
    case ADMIN_BIKE_REGISTER: // 车辆注册
        puthz(ADMIN_INTERFACE_X1 + 5, ADMIN_INTERFACE_Y1 + 5, "车辆注册审核", 24, 20, MY_WHITE);
        draw_cues(ADMIN_BUTTON1_X2+10, ADMIN_BUTTON1_Y1, NULL, NULL); // 绘制箭头，标明当前打开页面为此
        break;
    case ADMIN_BIKE_LICENSE: // 车辆上牌
        puthz(ADMIN_INTERFACE_X1 + 5, ADMIN_INTERFACE_Y1 + 5, "车辆上牌审核", 24, 20, MY_WHITE);
        draw_cues(ADMIN_BUTTON2_X2+10, ADMIN_BUTTON2_Y1, NULL, NULL); // 绘制箭头，标明当前打开页面为此
        break;
    case ADMIN_BIKE_BROKEN: // 车辆报废
        puthz(ADMIN_INTERFACE_X1 + 5, ADMIN_INTERFACE_Y1 + 5, "车辆报废审核", 24, 20, MY_WHITE);
        draw_cues(ADMIN_BUTTON3_X2 + 10, ADMIN_BUTTON3_Y1, NULL, NULL); // 绘制箭头，标明当前打开页面为此
        break;
    case ADMIN_BIKE_VIOLATION: // 车辆违规
        puthz(ADMIN_INTERFACE_X1 + 5, ADMIN_INTERFACE_Y1 + 5, "车辆违规审核", 24, 20, MY_WHITE);
        draw_cues(ADMIN_BUTTON4_X2 + 10, ADMIN_BUTTON4_Y1, NULL, NULL); // 绘制箭头，标明当前打开页面为此
        break;
    case ADMIN_BIKE_ANUAL: // 车辆年审
        puthz(ADMIN_INTERFACE_X1 + 5, ADMIN_INTERFACE_Y1 + 5, "车辆年审审核", 24, 20, MY_WHITE);
        draw_cues(ADMIN_BUTTON5_X2+10, ADMIN_BUTTON5_Y1, NULL, NULL); // 绘制箭头，标明当前打开页面为此
        break;
    }


    puthz(ADMIN_INTERFACE_X1 + 140, ADMIN_INTERFACE_Y1 + 10, "待处理项目", 16, 16, MY_WHITE);
    setcolor(MY_RED);
    settextstyle(DEFAULT_FONT, HORIZ_DIR, 1);
    outtextxy(ADMIN_INTERFACE_X1 + 130, ADMIN_INTERFACE_Y1 + 15, "-");

    if (page == ADMIN_BIKE_REGISTER || page == ADMIN_BIKE_LICENSE || page == ADMIN_BIKE_ANUAL)
    { // 车辆注册，车辆上牌，车辆年审
        puthz(ADMIN_INTERFACE_X1 + 20, ADMIN_INTERFACE_Y1 + 40, "姓名", 16, 16, MY_WHITE);
        puthz(ADMIN_INTERFACE_X1 + 100, ADMIN_INTERFACE_Y1 + 40, "学号", 16, 16, MY_WHITE);
        puthz(ADMIN_INTERFACE_X1 + 200, ADMIN_INTERFACE_Y1 + 40, "车辆车牌号", 16, 16, MY_WHITE);
    }
    else if (page == ADMIN_BIKE_VIOLATION || page == ADMIN_BIKE_BROKEN)
    { // 车辆违规，车辆报废
        puthz(ADMIN_INTERFACE_X1 + 20, ADMIN_INTERFACE_Y1 + 40, "学号", 16, 16, MY_WHITE);
        puthz(ADMIN_INTERFACE_X1 + 100, ADMIN_INTERFACE_Y1 + 40, "车辆车牌号", 16, 16, MY_WHITE);
        puthz(ADMIN_INTERFACE_X1 + 200, ADMIN_INTERFACE_Y1 + 40, "地点", 16, 16, MY_WHITE);
    }

    puthz(ADMIN_INTERFACE_X1 + 300, ADMIN_INTERFACE_Y1 + 40, "申请日期", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 400, ADMIN_INTERFACE_Y1 + 40, "处理情况", 16, 16, MY_WHITE);

    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(ADMIN_FEATURE1_X1, ADMIN_FEATURE1_Y1, ADMIN_FEATURE1_X2, ADMIN_FEATURE1_Y2);
    bar(ADMIN_FEATURE2_X1, ADMIN_FEATURE2_Y1, ADMIN_FEATURE2_X2, ADMIN_FEATURE2_Y2);
    bar(ADMIN_FEATURE3_X1, ADMIN_FEATURE3_Y1, ADMIN_FEATURE3_X2, ADMIN_FEATURE3_Y2);
    bar(ADMIN_FEATURE4_X1, ADMIN_FEATURE4_Y1, ADMIN_FEATURE4_X2, ADMIN_FEATURE4_Y2);
    bar(ADMIN_FEATURE5_X1, ADMIN_FEATURE5_Y1, ADMIN_FEATURE5_X2, ADMIN_FEATURE5_Y2);
    bar(ADMIN_FEATURE6_X1, ADMIN_FEATURE6_Y1, ADMIN_FEATURE6_X2, ADMIN_FEATURE6_Y2);
    puthz(ADMIN_FEATURE1_X1 + 4, ADMIN_FEATURE1_Y1 + 8, "同意申请", 16, 16, MY_WHITE);
    puthz(ADMIN_FEATURE2_X1 + 4, ADMIN_FEATURE2_Y1 + 8, "驳回申请", 16, 16, MY_WHITE);
    puthz(ADMIN_FEATURE3_X1 + 11, ADMIN_FEATURE3_Y1 + 8, "已处理", 16, 16, MY_WHITE);
    puthz(ADMIN_FEATURE4_X1 + 11, ADMIN_FEATURE4_Y1 + 8, "待处理", 16, 16, MY_WHITE);

    setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
    bar(ADMIN_FEATURE_SEARCH_X1, ADMIN_FEATURE_SEARCH_Y1, ADMIN_FEATURE_SEARCH_X2, ADMIN_FEATURE_SEARCH_Y2);
    setcolor(MY_BLACK);
    setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
    rectangle(ADMIN_FEATURE_SEARCH_X1, ADMIN_FEATURE_SEARCH_Y1, ADMIN_FEATURE_SEARCH_X2, ADMIN_FEATURE_SEARCH_Y2);

    setlinestyle(SOLID_LINE, 0, THICK_WIDTH); // 小放大镜，提示为搜索框
    line(ADMIN_FEATURE_SEARCH_X1 + 5, ADMIN_FEATURE_SEARCH_Y2 - 7, ADMIN_FEATURE_SEARCH_X1 + 12, ADMIN_FEATURE_SEARCH_Y2 - 14);
    circle(ADMIN_FEATURE_SEARCH_X1 + 16, ADMIN_FEATURE_SEARCH_Y2 - 18, 5);

    // setfillstyle(SOLID_FILL,MY_GREEN);
    // bar(ADMIN_INTERFACE_X1+10,ADMIN_INTERFACE_Y1+70,ADMIN_INTERFACE_X1+500,ADMIN_INTERFACE_Y1+390); // 清理列表
    clear_exit(ADMIN_FEATURE_EXIT_X1, ADMIN_FEATURE_EXIT_Y1, ADMIN_FEATURE_EXIT_X2, ADMIN_FEATURE_EXIT_Y2);
    clear_flip_up(ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_Y1, ADMIN_FEATURE_UP_X2, ADMIN_FEATURE_UP_Y2);
    clear_flip_down(ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_Y1, ADMIN_FEATURE_DOWN_X2, ADMIN_FEATURE_DOWN_Y2);
}

void drawgraph_admin_database(void)
{
    puthz(ADMIN_INTERFACE_X1 + 15, ADMIN_INTERFACE_Y1 + 5, "数据一览", 24, 20, MY_WHITE);
    draw_cues(ADMIN_BUTTON6_X2 + 10, ADMIN_BUTTON6_Y1, NULL, NULL); // 绘制箭头，标明当前打开页面为此

    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(ADMIN_FEATURE1_X1, ADMIN_FEATURE1_Y1, ADMIN_FEATURE1_X2, ADMIN_FEATURE1_Y2);
    bar(ADMIN_FEATURE2_X1, ADMIN_FEATURE2_Y1, ADMIN_FEATURE2_X2, ADMIN_FEATURE2_Y2);
    bar(ADMIN_FEATURE3_X1, ADMIN_FEATURE3_Y1, ADMIN_FEATURE3_X2, ADMIN_FEATURE3_Y2);
    bar(ADMIN_FEATURE4_X1, ADMIN_FEATURE4_Y1, ADMIN_FEATURE4_X2, ADMIN_FEATURE4_Y2);
    bar(ADMIN_FEATURE5_X1, ADMIN_FEATURE5_Y1, ADMIN_FEATURE5_X2, ADMIN_FEATURE5_Y2);
    bar(ADMIN_FEATURE6_X1, ADMIN_FEATURE6_Y1, ADMIN_FEATURE6_X2, ADMIN_FEATURE6_Y2);
    puthz(ADMIN_FEATURE1_X1 + 4, ADMIN_FEATURE1_Y1 + 8, "用户信息", 16, 16, MY_WHITE);
    puthz(ADMIN_FEATURE2_X1 + 4, ADMIN_FEATURE2_Y1 + 8, "车辆信息", 16, 16, MY_WHITE);
    puthz(ADMIN_FEATURE3_X1 + 4, ADMIN_FEATURE3_Y1 + 8, "出入统计", 16, 16, MY_WHITE);

    setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
    bar(ADMIN_FEATURE_SEARCH_X1, ADMIN_FEATURE_SEARCH_Y1, ADMIN_FEATURE_SEARCH_X2, ADMIN_FEATURE_SEARCH_Y2);
    setcolor(MY_BLACK);
    setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
    rectangle(ADMIN_FEATURE_SEARCH_X1, ADMIN_FEATURE_SEARCH_Y1, ADMIN_FEATURE_SEARCH_X2, ADMIN_FEATURE_SEARCH_Y2);

    setlinestyle(SOLID_LINE, 0, THICK_WIDTH); // 小放大镜，提示为搜索框
    line(ADMIN_FEATURE_SEARCH_X1 + 5, ADMIN_FEATURE_SEARCH_Y2 - 7, ADMIN_FEATURE_SEARCH_X1 + 12, ADMIN_FEATURE_SEARCH_Y2 - 14);
    circle(ADMIN_FEATURE_SEARCH_X1 + 16, ADMIN_FEATURE_SEARCH_Y2 - 18, 5);

    // setfillstyle(SOLID_FILL,MY_GREEN);
    // bar(ADMIN_INTERFACE_X1+10,ADMIN_INTERFACE_Y1+70,ADMIN_INTERFACE_X1+500,ADMIN_INTERFACE_Y1+390); // 清理列表
    clear_exit(ADMIN_FEATURE_EXIT_X1, ADMIN_FEATURE_EXIT_Y1, ADMIN_FEATURE_EXIT_X2, ADMIN_FEATURE_EXIT_Y2);
    clear_flip_up(ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_Y1, ADMIN_FEATURE_UP_X2, ADMIN_FEATURE_UP_Y2);
    clear_flip_down(ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_Y1, ADMIN_FEATURE_DOWN_X2, ADMIN_FEATURE_DOWN_Y2);
}

void drawgraph_admin_database_user_info(void)
{
    setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
    bar(ADMIN_INTERFACE_X1 + 115, ADMIN_INTERFACE_Y1 + 10, ADMIN_INTERFACE_X1 + 180, ADMIN_INTERFACE_Y1 + 30);
    bar(ADMIN_INTERFACE_X1 + 20, ADMIN_INTERFACE_Y1 + 40, ADMIN_INTERFACE_X1 + 520, ADMIN_INTERFACE_Y1 + 60); // 清理画面

    settextstyle(SCRIPT_FONT, HORIZ_DIR, 1);
    setcolor(MY_RED);
    outtextxy(ADMIN_INTERFACE_X1 + 100, ADMIN_INTERFACE_Y1,"-");
    puthz(ADMIN_INTERFACE_X1 + 115, ADMIN_INTERFACE_Y1 + 10, "用户信息", 16, 16, MY_WHITE);

    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(ADMIN_FEATURE6_X1, ADMIN_FEATURE6_Y1, ADMIN_FEATURE6_X2, ADMIN_FEATURE6_Y2);
    puthz(ADMIN_FEATURE6_X1 + 4, ADMIN_FEATURE6_Y1 + 8, "修改信息", 16, 16, MY_WHITE); // 显示新按钮

    puthz(ADMIN_INTERFACE_X1 + 20, ADMIN_INTERFACE_Y1 + 40, "学号", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 120, ADMIN_INTERFACE_Y1 + 40, "账号", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 240, ADMIN_INTERFACE_Y1 + 40, "密码", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 360, ADMIN_INTERFACE_Y1 + 40, "注册时间", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 460, ADMIN_INTERFACE_Y1 + 40, "状态", 16, 16, MY_WHITE);
}

void drawgraph_admin_database_ebike_info(void)
{
    setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
    bar(ADMIN_INTERFACE_X1 + 115, ADMIN_INTERFACE_Y1 + 10, ADMIN_INTERFACE_X1 + 180, ADMIN_INTERFACE_Y1 + 30);
    bar(ADMIN_INTERFACE_X1 + 20, ADMIN_INTERFACE_Y1 + 40, ADMIN_INTERFACE_X1 + 520, ADMIN_INTERFACE_Y1 + 60); // 清理画面

    settextstyle(SCRIPT_FONT, HORIZ_DIR, 1);
    setcolor(MY_RED);
    outtextxy(ADMIN_INTERFACE_X1 + 100, ADMIN_INTERFACE_Y1,"-");
    puthz(ADMIN_INTERFACE_X1 + 115, ADMIN_INTERFACE_Y1 + 10, "车辆信息", 16, 16, MY_WHITE);

    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(ADMIN_FEATURE6_X1, ADMIN_FEATURE6_Y1, ADMIN_FEATURE6_X2, ADMIN_FEATURE6_Y2);
    puthz(ADMIN_FEATURE6_X1 + 4, ADMIN_FEATURE6_Y1 + 8, "修改信息", 16, 16, MY_WHITE); // 显示新按钮

    puthz(ADMIN_INTERFACE_X1 + 20, ADMIN_INTERFACE_Y1 + 40, "学号", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 120, ADMIN_INTERFACE_Y1 + 40, "车辆车牌号", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 240, ADMIN_INTERFACE_Y1 + 40, "车辆证号", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 360, ADMIN_INTERFACE_Y1 + 40, "车辆地址", 16, 16, MY_WHITE);
    puthz(ADMIN_INTERFACE_X1 + 460, ADMIN_INTERFACE_Y1 + 40, "状态", 16, 16, MY_WHITE);
}

void drawgraph_admin_info(unsigned long ID)
{
    char buffer[20]; // 用于存储格式化后的字符串

    puthz(ADMIN_INTERFACE_X1 + 20, ADMIN_INTERFACE_Y1 + 20, "你好！", 24, 30, MY_WHITE); // 输出文本

    sprintf(buffer, "%lu", ID); // 将 ID 转换为字符串
    setcolor(MY_WHITE);
    settextstyle(SCRIPT_FONT, HORIZ_DIR, 2);
    outtextxy(ADMIN_INTERFACE_X1 + 110, ADMIN_INTERFACE_Y1 + 16, buffer); // 输出名称
}

void draw_person(int x1,int y1,int x2,int y2){
    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(x1 - 3, y1 - 3, x2 + 3, y2 + 3);
    setcolor(MY_BLACK);
    setfillstyle(SOLID_FILL, MY_BLACK);
    pieslice(x1+10, y1 +7, 0, 360, 6);   // 绘制人头
    pieslice(x1+10, y1 + 22, 0, 180, 11); // 绘制身体
}
void clear_person(int x1,int y1,int x2,int y2){
    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(x1 - 3, y1 - 3, x2 + 3, y2 + 3);
    setcolor(MY_BLACK);
    setfillstyle(SOLID_FILL, MY_BLACK);
    pieslice(x1+10, y1 +7, 0, 360, 5);   // 绘制人头
    pieslice(x1+10, y1 + 22, 0, 180, 10); // 绘制身体
}

void draw_cues(int x, int y,int null1,int null2){
    setcolor(MY_GREEN);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    line(x-10,y+23,x,y+23);
    line(x-5,y+18,x,y+23);
    line(x-5,y+28,x,y+23);
}
void clear_cues(int x1, int y1, int x2, int y2){
    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(x1-13,y1+6,x2-79,y2);
}

void draw_rectangle(int x1,int y1,int x2,int y2){
    setcolor(MY_WHITE);
    setlinestyle(SOLID_LINE,0,NORM_WIDTH);
    rectangle(x1-2,y1-2,x2+2,y2+2);
}

void clear_rectangle(int x1,int y1,int x2,int y2){
    setcolor(MY_LIGHTGRAY);
    setlinestyle(SOLID_LINE,0,NORM_WIDTH);
    rectangle(x1-2,y1-2,x2+2,y2+2);
}

void draw_exit(int x1,int y1,int x2,int y2){
    setcolor(MY_RED);
    setlinestyle(SOLID_LINE,0,THICK_WIDTH);
    line(x1,y1,x2,y2);
    line(x2,y1,x1,y2);
}
void clear_exit(int x1,int y1,int x2,int y2){
    setfillstyle(SOLID_FILL,MY_YELLOW);
    bar(x1-1,y1-1,x2+1,y2+1);

    setcolor(MY_RED);
    setlinestyle(SOLID_LINE,0,NORM_WIDTH);
    line(x1,y1,x2,y2);
    line(x2,y1,x1,y2);
}

void draw_exit_menu(int x1,int y1,int x2,int y2){
    setcolor(MY_BLACK);
    setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
    rectangle(x1,y1,x2,y2);
    puthz(x1+2,y1+7,"退出登录",16,16,MY_WHITE);
    puthz(x1+2,y1+29,"退出程序",16,16,MY_WHITE);
}
void clear_exit_menu(int x1,int y1,int x2,int y2){
    setfillstyle(SOLID_FILL,MY_YELLOW);
    bar(x1,y1,x2,y2);
}

void draw_flip_up(int x1, int y1, int x2, int y2)
{
    setcolor(BLACK);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    line(ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_Y1 + 10, ADMIN_FEATURE_UP_X2, ADMIN_FEATURE_UP_Y1);
    line(ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_Y1 + 10, ADMIN_FEATURE_UP_X2, ADMIN_FEATURE_UP_Y2); // 切换页面 <
}
void draw_flip_down(int x1, int y1, int x2, int y2)
{
    setcolor(BLACK);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    line(ADMIN_FEATURE_DOWN_X2, ADMIN_FEATURE_DOWN_Y1 + 10, ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_Y1);
    line(ADMIN_FEATURE_DOWN_X2, ADMIN_FEATURE_DOWN_Y1 + 10, ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_Y2); // 切换页面 >
}
void clear_flip_up(int x1, int y1, int x2, int y2)
{
    setcolor(MY_YELLOW);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    line(ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_Y1 + 10, ADMIN_FEATURE_UP_X2, ADMIN_FEATURE_UP_Y1);
    line(ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_Y1 + 10, ADMIN_FEATURE_UP_X2, ADMIN_FEATURE_UP_Y2); // 切换页面 <
}
void clear_flip_down(int x1, int y1, int x2, int y2)
{
    setcolor(MY_YELLOW);
    setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
    line(ADMIN_FEATURE_DOWN_X2, ADMIN_FEATURE_DOWN_Y1 + 10, ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_Y1);
    line(ADMIN_FEATURE_DOWN_X2, ADMIN_FEATURE_DOWN_Y1 + 10, ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_Y2); // 切换页面 >
}



// 这个函数可能还需要进一步优化，若之后出现画面抽搐的问题尚不能解决，就干这个函数
// 2025.3.19 出错：连个静态变量索引导入结构体数组导致越界。通过将其定义值改为0暂时解
// 2025.4.4 将按钮初始化模块化后，又出现了类似问题。交给AI处理后，该函数添加了一些防指针越界的语句，暂时解决了问题
void admin_flush_buttons(int *tag, int button_counts, ADMIN_BUTTONS AdminButtons[])
{
    int i;
    int new_tag = ACTIVE_ADMIN_NULL;
    static int last_active_index = 0;
    static int current_active_index = 0;

    // 检查按钮数量是否合法
    if (button_counts <= 0 || !AdminButtons)
    {
        return;
    }

    // 检查鼠标是否在任一按钮区域内
    for (i = 0; i < button_counts; i++)
    {
        if (MouseX >= AdminButtons[i].x1 && MouseX <= AdminButtons[i].x2 &&
            MouseY >= AdminButtons[i].y1 && MouseY <= AdminButtons[i].y2)
        {
            new_tag = AdminButtons[i].active_tag;
            last_active_index = current_active_index;
            current_active_index = i;
            break;
        }
    }

    // 状态变化时更新
    if (*tag != new_tag)
    {
        *tag = new_tag;
        if (new_tag != ACTIVE_ADMIN_NULL)
        {
            // 绘制提示（同时清除上一次高光提示）
            if (last_active_index >= 0 && last_active_index < button_counts)
            {
                AdminButtons[last_active_index].clearfunc(
                    AdminButtons[last_active_index].x1,
                    AdminButtons[last_active_index].y1,
                    AdminButtons[last_active_index].x2,
                    AdminButtons[last_active_index].y2);
            }
            if (current_active_index >= 0 && current_active_index < button_counts)
            {
                AdminButtons[current_active_index].drawfunc(
                    AdminButtons[current_active_index].x1,
                    AdminButtons[current_active_index].y1,
                    AdminButtons[current_active_index].x2,
                    AdminButtons[current_active_index].y2);
            }
            last_active_index = current_active_index;
            MouseS = 1;
        }
        else
        {
            // 清除提示
            if (last_active_index >= 0 && last_active_index < button_counts)
            {
                AdminButtons[last_active_index].clearfunc(
                    AdminButtons[last_active_index].x1,
                    AdminButtons[last_active_index].y1,
                    AdminButtons[last_active_index].x2,
                    AdminButtons[last_active_index].y2);
                last_active_index = -1;
            }
            MouseS = 0;
        }
    }
}

/*****************************************************************
MODULE:该源文件全局可使用的函数模块
*****************************************************************/

// 查找文件中是否存在指定内容，并返回该数据块位置
unsigned long int find_ebike_info(FILE *fp,char *search_str,char *search_needed){
    int counts;
    unsigned long int pos;
    unsigned long int search_pos = 0;
    EBIKE_INFO TEMP;

    pos = ftell(fp); // 记录当前文件指针位置，以便后续返回

    fseek(fp,0,SEEK_END);
    counts = ftell(fp) / sizeof(EBIKE_INFO);
    fseek(fp,0,SEEK_SET); // 获取文件长度
    
    while(fread(&TEMP,sizeof(EBIKE_INFO),1,fp)){
        if(TEMP.ID == NULL){
            fseek(fp, pos, SEEK_SET); // 将文件指针移回原先位置
            return 0;
        } // 查找到文件结束时仍未找到，则返回0
            

        if ((strcmp(search_needed, "realname") == 0 && strcmp(TEMP.rln, search_str) == 0) ||
            (strcmp(search_needed, "id") == 0 && TEMP.ID == atol(search_str)) ||
            (strcmp(search_needed, "ebike_id") == 0 && strcmp(TEMP.ebike_ID, search_str) == 0) ||
            (strcmp(search_needed, "ebike_license") == 0 && strcmp(TEMP.ebike_license, search_str) == 0) ||
            (strcmp(search_needed, "location") == 0 && strcmp(TEMP.location, search_str) == 0) ||
            (strcmp(search_needed, "apply_time") == 0 && TEMP.apply_time == atol(search_str)) ||
            (strcmp(search_needed, "conduct_time") == 0 && TEMP.conduct_time == atol(search_str)) ||
            (strcmp(search_needed, "result") == 0 && TEMP.result == atoi(search_str))
            )
        {
            fseek(fp, -sizeof(EBIKE_INFO), SEEK_CUR); // 将文件指针移动到对应数据前
            search_pos = ftell(fp);                   // 记录数据块位置
            fseek(fp, pos, SEEK_SET);                 // 将文件指针移回原先位置
            break;
        } // 查找到后，跳出循环
    }

    return search_pos; // 文件指针位置返回到原先位置
}

// 点击按钮后，若能成功操作，则执行该显示动画
void admin_pass_failed_anime(int button_x1, int button_y1, int button_x2, int button_y2,int result)
{
    int tick = 0;
    clrmous(MouseX, MouseY); // 清除鼠标

    for (tick = 0; tick <= 80; tick++)
    {
        if (tick % 40 == 0)
        {
            setfillstyle(SOLID_FILL, GREEN);
            bar(button_x1, button_y1, button_x2, button_y2);
            if(result == PASSED)
                puthz(button_x1 + 4, button_y1 + 8, "通过成功", 16, 16, MY_WHITE); // 绘制按钮
            else if(result == FAILED)
                puthz(button_x1 + 4, button_y1 + 8, "驳回成功", 16, 16, MY_WHITE); // 绘制按钮
        }
        else if (tick % 40 == 20)
        {
            setfillstyle(SOLID_FILL, MY_YELLOW);
            bar(button_x1, button_y1, button_x2, button_y2);
            if(result == PASSED)
                puthz(button_x1 + 4, button_y1 + 8, "通过成功", 16, 16, MY_WHITE); // 绘制按钮
            else if(result == FAILED)
                puthz(button_x1 + 4, button_y1 + 8, "通过成功", 16, 16, MY_WHITE); // 绘制按钮
        }
        delay(25);
    }
    setfillstyle(SOLID_FILL, MY_YELLOW);
    bar(button_x1, button_y1, button_x2, button_y2);                  // 重绘按钮
    puthz(button_x1 + 4, button_y1 + 8, "同意申请", 16, 16, MY_WHITE); // 重新绘制按钮        

    newmouse(&MouseX, &MouseY, &press); // 重新绘制
}

void define_admin_buttons(ADMIN_BUTTONS AdminButtons[], int button_counts)
{
    ADMIN_BUTTONS Examples[] = {
        {ADMIN_BUTTON1_X1, ADMIN_BUTTON1_X2,
         ADMIN_BUTTON1_Y1, ADMIN_BUTTON1_Y2,
         ACTIVE_ADMIN_BUTTON1, &draw_cues, &clear_cues},
        {ADMIN_BUTTON2_X1, ADMIN_BUTTON2_X2,
         ADMIN_BUTTON2_Y1, ADMIN_BUTTON2_Y2,
         ACTIVE_ADMIN_BUTTON2, &draw_cues, &clear_cues},
        {ADMIN_BUTTON3_X1, ADMIN_BUTTON3_X2,
         ADMIN_BUTTON3_Y1, ADMIN_BUTTON3_Y2,
         ACTIVE_ADMIN_BUTTON3, &draw_cues, &clear_cues},
        {ADMIN_BUTTON4_X1, ADMIN_BUTTON4_X2,
         ADMIN_BUTTON4_Y1, ADMIN_BUTTON4_Y2,
         ACTIVE_ADMIN_BUTTON4, &draw_cues, &clear_cues},
        {ADMIN_BUTTON5_X1, ADMIN_BUTTON5_X2,
         ADMIN_BUTTON5_Y1, ADMIN_BUTTON5_Y2,
         ACTIVE_ADMIN_BUTTON5, &draw_cues, &clear_cues},
        {ADMIN_BUTTON6_X1, ADMIN_BUTTON6_X2,
         ADMIN_BUTTON6_Y1, ADMIN_BUTTON6_Y2,
         ACTIVE_ADMIN_BUTTON6, &draw_cues, &clear_cues},
        {ADMIN_BUTTON7_X1, ADMIN_BUTTON7_X2,
         ADMIN_BUTTON7_Y1, ADMIN_BUTTON7_Y2,
         ACTIVE_ADMIN_BUTTON7, &draw_cues, &clear_cues},
        {ADMIN_EXIT_X1, ADMIN_EXIT_X2,
         ADMIN_EXIT_Y1, ADMIN_EXIT_Y2,
         ACTIVE_ADMIN_EXIT, &draw_exit, &clear_exit},
        {ADMIN_INFO_X1, ADMIN_INFO_X2,
         ADMIN_INFO_Y1, ADMIN_INFO_Y2,
         ACTIVE_ADMIN_INFO, &draw_person, &clear_person},
        {ADMIN_FEATURE1_X1, ADMIN_FEATURE1_X2,
         ADMIN_FEATURE1_Y1, ADMIN_FEATURE1_Y2,
         ACTIVE_ADMIN_FEATURE1, &draw_rectangle, &clear_rectangle},
        {ADMIN_FEATURE2_X1, ADMIN_FEATURE2_X2,
         ADMIN_FEATURE2_Y1, ADMIN_FEATURE2_Y2,
         ACTIVE_ADMIN_FEATURE2, &draw_rectangle, &clear_rectangle},
        {ADMIN_FEATURE3_X1, ADMIN_FEATURE3_X2,
         ADMIN_FEATURE3_Y1, ADMIN_FEATURE3_Y2,
         ACTIVE_ADMIN_FEATURE3, &draw_rectangle, &clear_rectangle},
        {ADMIN_FEATURE4_X1, ADMIN_FEATURE4_X2,
         ADMIN_FEATURE4_Y1, ADMIN_FEATURE4_Y2,
         ACTIVE_ADMIN_FEATURE4, &draw_rectangle, &clear_rectangle},
        {ADMIN_FEATURE5_X1, ADMIN_FEATURE5_X2,
         ADMIN_FEATURE5_Y1, ADMIN_FEATURE5_Y2,
         ACTIVE_ADMIN_FEATURE5, &draw_rectangle, &clear_rectangle},
        {ADMIN_FEATURE6_X1, ADMIN_FEATURE6_X2,
         ADMIN_FEATURE6_Y1, ADMIN_FEATURE6_Y2,
         ACTIVE_ADMIN_FEATURE6, &draw_rectangle, &clear_rectangle},
        {ADMIN_FEATURE_EXIT_X1, ADMIN_FEATURE_EXIT_X2,
         ADMIN_FEATURE_EXIT_Y1, ADMIN_FEATURE_EXIT_Y2,
         ACTIVE_ADMIN_FEATURE_EXIT, &draw_exit, &clear_exit},
        {ADMIN_FEATURE_SEARCH_X1, ADMIN_FEATURE_SEARCH_X2,
         ADMIN_FEATURE_SEARCH_Y1, ADMIN_FEATURE_SEARCH_Y2,
         ACTIVE_ADMIN_FEATURE_SEARCH, &draw_rectangle, &clear_rectangle},
        {ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_X2,
         ADMIN_FEATURE_UP_Y1, ADMIN_FEATURE_UP_Y2,
         ACTIVE_ADMIN_FEATURE_UP, &draw_flip_up, &clear_flip_up},
        {ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_X2,
         ADMIN_FEATURE_DOWN_Y1, ADMIN_FEATURE_DOWN_Y2,
         ACTIVE_ADMIN_FEATURE_DOWN, &draw_flip_down, &clear_flip_down}};
    int i;
    for (i = 0; i < button_counts; i++)
    {
        if(i >= STRUCT_LENGTH(Examples))
            break;
        AdminButtons[i].x1 = Examples[i].x1;
        AdminButtons[i].x2 = Examples[i].x2;
        AdminButtons[i].y1 = Examples[i].y1;
        AdminButtons[i].y2 = Examples[i].y2;
        AdminButtons[i].active_tag = Examples[i].active_tag;
        AdminButtons[i].drawfunc = Examples[i].drawfunc;
        AdminButtons[i].clearfunc = Examples[i].clearfunc;
    }
}

void admin_handle_buttons_event(int *page)
{
    /*返回主界面或退出程序*/
    if (mouse_press(ADMIN_EXIT_X1, ADMIN_EXIT_Y1, ADMIN_EXIT_X2, ADMIN_EXIT_Y2) == 1)
    {
        if (!admin_exitting(page))
        {
            AdminswitchPage();
            return;
        }
    }
    /*查看个人信息*/
    if (mouse_press(ADMIN_INFO_X1, ADMIN_INFO_Y1, ADMIN_INFO_X2, ADMIN_INFO_Y2) == 1)
    {
        if (*page != ADMIN_INFO)
        {
            *page = ADMIN_INFO;
            return;
        }
    }

    /*车辆注册*/
    if (mouse_press(ADMIN_BUTTON1_X1, ADMIN_BUTTON1_Y1, ADMIN_BUTTON1_X2, ADMIN_BUTTON1_Y2) == 1 &&
        *page != ADMIN_BIKE_REGISTER)
    {
        *page = ADMIN_BIKE_REGISTER;
        return;
    }
    /*车辆上牌*/
    if (mouse_press(ADMIN_BUTTON2_X1, ADMIN_BUTTON2_Y1, ADMIN_BUTTON2_X2, ADMIN_BUTTON2_Y2) == 1 &&
        *page != ADMIN_BIKE_LICENSE)
    {
        *page = ADMIN_BIKE_LICENSE;
        return;
    }
    /*车辆报废*/
    if (mouse_press(ADMIN_BUTTON3_X1, ADMIN_BUTTON3_Y1, ADMIN_BUTTON3_X2, ADMIN_BUTTON3_Y2) == 1 &&
        *page != ADMIN_BIKE_BROKEN)
    {
        *page = ADMIN_BIKE_BROKEN;
        return;
    }
    /*车辆违规*/
    if (mouse_press(ADMIN_BUTTON4_X1, ADMIN_BUTTON4_Y1, ADMIN_BUTTON4_X2, ADMIN_BUTTON4_Y2) == 1 &&
        *page != ADMIN_BIKE_VIOLATION)
    {
        *page = ADMIN_BIKE_VIOLATION;
        return;
    }
    /*车辆年审*/
    if (mouse_press(ADMIN_BUTTON5_X1, ADMIN_BUTTON5_Y1, ADMIN_BUTTON5_X2, ADMIN_BUTTON5_Y2) == 1 &&
        *page != ADMIN_BIKE_ANUAL)
    {
        *page = ADMIN_BIKE_ANUAL;
        return;
    }

    /*数据一揽*/
    if (mouse_press(ADMIN_BUTTON6_X1, ADMIN_BUTTON6_Y1, ADMIN_BUTTON6_X2, ADMIN_BUTTON6_Y2) == 1 &&
        *page!= ADMIN_DATABASE)
    {
        *page = ADMIN_DATABASE;
        return; 
    }
}

void admin_handle_manage_feature_event(LINKLIST *LIST, int *page, char *search_str, unsigned long *id_list, FILE *fp_EBIKE_INFO_read, int *mode, int selected_id)
{
    int i;
    char list_mode[10]; // 列表依据
    char buffer[50];
    EBIKE_INFO temp_info;
    LINKLIST_NODE *temp_node = LIST->HEAD; // LAST_NODE要找到链表中特定节点，先指向头结点
    int chain_pos = -1;                    // 链表位置

    unsigned long int search_pos = 0; // 查找数据得到的位置

    // 根据不同的页面，以不同的方式调用列表函数
    switch (*page)
    {
    case ADMIN_BIKE_REGISTER:
        strcpy(list_mode, "register");
        break;
    case ADMIN_BIKE_LICENSE:
        strcpy(list_mode, "license");
        break;
    case ADMIN_BIKE_VIOLATION:
        strcpy(list_mode, "violation");
        break;
    case ADMIN_BIKE_ANUAL:
        strcpy(list_mode, "annual");
        break;
    case ADMIN_BIKE_BROKEN:
        strcpy(list_mode, "broken");
        break;
    }

    if (mouse_press(ADMIN_FEATURE_EXIT_X1, ADMIN_FEATURE_EXIT_Y1, ADMIN_FEATURE_EXIT_X2, ADMIN_FEATURE_EXIT_Y2) == 1)
    {
        *page = MAIN_ADMIN;
    } // 当在功能界面点击叉，退出功能界面

    if (mouse_press(ADMIN_FEATURE_SEARCH_X1, ADMIN_FEATURE_SEARCH_Y1, ADMIN_FEATURE_SEARCH_X2, ADMIN_FEATURE_SEARCH_Y2) == 1)
    {
        Input_Bar(search_str, ADMIN_FEATURE_SEARCH_X1 + 25, ADMIN_FEATURE_SEARCH_Y1 + 2, 9, MY_LIGHTGRAY, 0, 1);

        selected_id = -1; // 清除选中行
        setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
        bar(ADMIN_INTERFACE_X1 + 10, ADMIN_INTERFACE_Y1 + 70, ADMIN_INTERFACE_X1 + 18, ADMIN_INTERFACE_Y1 + 310); // 清理所有选中行高亮

        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp_EBIKE_INFO_read, "ebike_manage",
                        list_mode, *mode, 0, 2, search_str, "ID"); // 搜索后刷新列表

    } // 点击输入框后退回

    if (mouse_press(ADMIN_FEATURE3_X1, ADMIN_FEATURE3_Y1, ADMIN_FEATURE3_X2, ADMIN_FEATURE3_Y2) == 1 &&
        *mode == 0)
    {
        *mode = 1;
        setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
        bar(ADMIN_INTERFACE_X1 + 140, ADMIN_INTERFACE_Y1 + 10, ADMIN_INTERFACE_X1 + 230, ADMIN_INTERFACE_Y1 + 30);
        puthz(ADMIN_INTERFACE_X1 + 140, ADMIN_INTERFACE_Y1 + 10, "已处理项目", 16, 16, MY_WHITE);
        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp_EBIKE_INFO_read, "ebike_manage",
                        list_mode, *mode, LIST_STAY, LIST_CLEAR_CONTINUE, search_str, "ID");
    } // 点击已处理后显示已处理

    if (mouse_press(ADMIN_FEATURE4_X1, ADMIN_FEATURE4_Y1, ADMIN_FEATURE4_X2, ADMIN_FEATURE4_Y2) == 1 &&
        *mode == 1)
    {
        *mode = 0;
        setfillstyle(SOLID_FILL, MY_LIGHTGRAY);
        bar(ADMIN_INTERFACE_X1 + 140, ADMIN_INTERFACE_Y1 + 10, ADMIN_INTERFACE_X1 + 230, ADMIN_INTERFACE_Y1 + 30);
        puthz(ADMIN_INTERFACE_X1 + 140, ADMIN_INTERFACE_Y1 + 10, "未处理项目", 16, 16, MY_WHITE);
        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp_EBIKE_INFO_read, "ebike_manage",
                        list_mode, *mode, LIST_STAY, LIST_CLEAR_CONTINUE, search_str, "ID");
    } // 点击未处理后显示未处理

    // 点击同意申请
    if (mouse_press(ADMIN_FEATURE1_X1, ADMIN_FEATURE1_Y1, ADMIN_FEATURE1_X2, ADMIN_FEATURE1_Y2) == 1 && selected_id != -1)
    {
        itoa(selected_id, buffer, 10);                                  // 将选中行的ID转化为字符串
        if ((chain_pos = linklist_find_data(LIST, buffer, "id")) == -1) // 查找链表中是否存在该ID，若找不到，则不进行任何操作
            return;

        search_pos = find_ebike_info(fp_EBIKE_INFO_read, buffer, "id"); // 查找数据块
        if (search_pos == 0)
            return; // 如果没有找到数据块，则不进行任何操作，若能找到，则进一步处理数据

        // 修改数据块
        
        fread(&temp_info, sizeof(EBIKE_INFO), 1, fp_EBIKE_INFO_read);                     // 读取数据块
        temp_info.conduct_time = get_approx_time(NULL);                                   // 将时间字符串转化为int型数据，并赋值给conduct_time
        temp_info.result = PASSED;                                                        // 将result赋值为已处理

        fseek(fp_EBIKE_INFO_read, search_pos, SEEK_SET);               // 定位到数据块
        fwrite(&temp_info, sizeof(EBIKE_INFO), 1, fp_EBIKE_INFO_read); // 将新数据写入数据块

        // 修改链表数据
        for (i = 0; i < chain_pos; i++)
        {
            temp_node = temp_node->NEXT; // 遍历链表，找到对应节点
        }
        // 根据不同的页面，修改链表中对应节点的特定数据
        switch (*page)
        {
        case ADMIN_BIKE_REGISTER:
            strcpy(temp_node->USER_DATA.ebike_ID, temp_info.ebike_ID); // 将链表中对应节点的ebike_ID修改为新数据
            break;
        case ADMIN_BIKE_LICENSE:
            strcpy(temp_node->USER_DATA.ebike_license, temp_info.ebike_license); // 将链表中对应节点的ebike_license修改为新数据
            break;
        case ADMIN_BIKE_VIOLATION:
            temp_node->USER_DATA.violations++;
            ; // 将链表中对应节点的violations加1
            break;
        case ADMIN_BIKE_ANUAL:
            temp_node->USER_DATA.anual_check += 10000; // 将链表中对应节点的annual加10000(10000表示数字中表示年的部分加1)
            break;
        case ADMIN_BIKE_BROKEN:
            temp_node->USER_DATA.ebike_state = BROKEN; // 将链表中对应节点的ebike_state修改为BROKEN
            break;
        }
        linklist_write_user_data(LIST); // 将链表数据写入文件

        admin_pass_failed_anime(ADMIN_FEATURE1_X1, ADMIN_FEATURE1_Y1, ADMIN_FEATURE1_X2, ADMIN_FEATURE1_Y2, PASSED); // 操作成功后的动画

        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp_EBIKE_INFO_read, "ebike_manage",
                        list_mode, *mode, LIST_PAGEDOWN, LIST_FLUSH, "\0", "\0"); // 操作结束后刷新列表
    }

    // 点击拒绝申请
    if (mouse_press(ADMIN_FEATURE2_X1, ADMIN_FEATURE2_Y1, ADMIN_FEATURE2_X2, ADMIN_FEATURE2_Y2) == 1 && selected_id != -1)
    {
        itoa(selected_id, buffer, 10);
        if (!(chain_pos = linklist_find_data(LIST, buffer, "id")))
            return; // 选中行，点击同意申请，若出现未能找到数据的情况，则不进行任何操作

        search_pos = find_ebike_info(fp_EBIKE_INFO_read, buffer, "id"); // 查找数据块
        if (search_pos == 0)
            return; // 如果没有找到数据块，则不进行任何操作，若能找到，则进一步处理数据

        // 修改数据块
        fread(&temp_info, sizeof(EBIKE_INFO), 1, fp_EBIKE_INFO_read);                     // 读取数据块
        temp_info.conduct_time = get_approx_time(NULL);                                              // 将时间字符串转化为int型数据，并赋值给conduct_time
        temp_info.result = FAILED;                                                        // 将result赋值为已处理

        fseek(fp_EBIKE_INFO_read, search_pos, SEEK_SET);               // 定位到数据块
        fwrite(&temp_info, sizeof(EBIKE_INFO), 1, fp_EBIKE_INFO_read); // 将新数据写入数据块

        // 申请失败，不修改链表数据

        admin_pass_failed_anime(ADMIN_FEATURE1_X1, ADMIN_FEATURE1_Y1, ADMIN_FEATURE1_X2, ADMIN_FEATURE1_Y2, FAILED); // 操作成功后的动画

        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp_EBIKE_INFO_read, "ebike_manage",
                        list_mode, *mode, LIST_PAGEDOWN, LIST_FLUSH, "\0", "\0"); // 操作结束后刷新列表
    }
    temp_node = NULL; // 释放指针
}

void admin_handle_database_event(LINKLIST *LIST, int *flag , int *page, unsigned long *id_list, FILE *fp, char *search_str)
{
    char file_type[20];

    switch (*flag){ // 枚举情况，在数据库中不会单独打开五个特性功能的文件，所以不列举ebike_manage
        case ADMIN_DATABASE_USER_INFO:
            strcpy(file_type, "user_data");
            break;
        case ADMIN_DATABASE_EBIKE_INFO:
            strcpy(file_type, "ebike_data");
            break;
        case ADMIN_DATABASE_EBIKE_PASS_IN_OUT:
            strcpy(file_type, "ebike_pass_in_out");
            break;
        case ADMIN_DATABASE_NULL:
            break;
        default:
            return; // 不正确的文件类型标志，不做任何操作
    }

    /*点击退出按钮*/
    if (mouse_press(ADMIN_FEATURE_EXIT_X1, ADMIN_FEATURE_EXIT_Y1, ADMIN_FEATURE_EXIT_X2, ADMIN_FEATURE_EXIT_Y2) == 1)
    {
        *page = MAIN_ADMIN;
        return;
    }
    /*点击用户信息*/
    if (mouse_press(ADMIN_FEATURE1_X1, ADMIN_FEATURE1_Y1, ADMIN_FEATURE1_X2, ADMIN_FEATURE1_Y2) == 1 &&
        *flag != ADMIN_DATABASE_USER_INFO)
    {
        drawgraph_admin_database_user_info();
        *flag = ADMIN_DATABASE_USER_INFO;
        strcpy(file_type, "user_data");
        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp, file_type, NULL, NULL, LIST_STAY, LIST_CLEAR_CONTINUE, search_str, "ID");
        return;
    }
    /*点击车辆信息*/
    if (mouse_press(ADMIN_FEATURE2_X1, ADMIN_FEATURE2_Y1, ADMIN_FEATURE2_X2, ADMIN_FEATURE2_Y2) == 1 &&
        *flag != ADMIN_DATABASE_EBIKE_INFO)
    {
        drawgraph_admin_database_ebike_info();
        *flag = ADMIN_DATABASE_EBIKE_INFO;
        strcpy(file_type, "ebike_data");
        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, NULL, file_type, NULL, NULL, LIST_STAY, LIST_CLEAR_CONTINUE, search_str, "ID");
        return;
    }
    /*点击车辆出入信息*/
    if (mouse_press(ADMIN_FEATURE3_X1, ADMIN_FEATURE3_Y1, ADMIN_FEATURE3_X2, ADMIN_FEATURE3_Y2) == 1 &&
        *flag != ADMIN_DATABASE_EBIKE_PASS_IN_OUT)
    {
        *flag = ADMIN_DATABASE_EBIKE_PASS_IN_OUT;
        return;
    }
    /*点击翻页*/
    if (mouse_press(ADMIN_FEATURE_UP_X1, ADMIN_FEATURE_UP_Y1, ADMIN_FEATURE_UP_X2, ADMIN_FEATURE_UP_Y2) == 1){
        if (*flag != ADMIN_DATABASE_EBIKE_INFO){
            admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp, file_type, NULL, NULL, LIST_PAGEUP, LIST_NO_CLEAR, search_str, "ID");
        }
        else if (*flag == ADMIN_DATABASE_EBIKE_INFO){
            admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp, file_type, NULL, NULL, LIST_PAGEUP, LIST_NO_CLEAR, search_str, "ID");
        }
        return;
    }
    if (mouse_press(ADMIN_FEATURE_DOWN_X1, ADMIN_FEATURE_DOWN_Y1, ADMIN_FEATURE_DOWN_X2, ADMIN_FEATURE_DOWN_Y2) == 1){
        if (*flag != ADMIN_DATABASE_EBIKE_INFO){
            admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp, file_type, NULL, NULL, LIST_PAGEDOWN, LIST_NO_CLEAR, search_str, "ID"); 
        }
        else if (*flag == ADMIN_DATABASE_EBIKE_INFO){
            admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp, file_type, NULL, NULL, LIST_PAGEDOWN, LIST_NO_CLEAR, search_str, "ID");
        }
        return;
    }
    /*点击搜索框*/
    if (mouse_press(ADMIN_FEATURE_SEARCH_X1, ADMIN_FEATURE_SEARCH_Y1, ADMIN_FEATURE_SEARCH_X2, ADMIN_FEATURE_SEARCH_Y2) == 1)
    {
        Input_Bar(search_str, ADMIN_FEATURE_SEARCH_X1 + 25, ADMIN_FEATURE_SEARCH_Y1 + 2, 9, MY_LIGHTGRAY, 0, 1);

        admin_list_info(LIST, LIST_LIMIT, LIST_INTERVAL, id_list, fp, file_type, NULL, NULL, LIST_STAY, LIST_CLEAR_CONTINUE, search_str, "ID"); // 搜索后刷新列表
        return;
    }
}

int admin_exitting(int *page)
{
    draw_exit_menu(ADMIN_EXIT_MENU_X1, ADMIN_EXIT_MENU_Y1, ADMIN_EXIT_MENU_X2, ADMIN_EXIT_MENU_Y2);
    while (1)
    {
        newmouse(&MouseX, &MouseY, &press);
        if (mouse_press(ADMIN_EXIT_MENU_X1 + 2, ADMIN_EXIT_MENU_Y1 + 5, ADMIN_EXIT_MENU_X1 + 60, ADMIN_EXIT_MENU_Y1 + 21) == 1)
        {
            *page = LOGIN_ADMIN;
            admin_list_info(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, LIST_CLEAR, NULL, NULL);
            Input_Bar(NULL, NULL, NULL, NULL, NULL, INPUTBAR_CLEAR, NULL);
            return 0;
        }
        else if (mouse_press(ADMIN_EXIT_MENU_X1 + 2, ADMIN_EXIT_MENU_Y1 + 30, ADMIN_EXIT_MENU_X1 + 60, ADMIN_EXIT_MENU_Y1 + 46) == 1)
        {
            *page = EXIT;
            admin_list_info(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, LIST_CLEAR, NULL, NULL);
            Input_Bar(NULL, NULL, NULL, NULL, NULL, INPUTBAR_CLEAR, NULL);
            return 0;
        }
        else if (mouse_press(0, 0, 640, 480) == 1 && mouse_press(ADMIN_EXIT_X1, ADMIN_EXIT_Y1, ADMIN_EXIT_X2, ADMIN_EXIT_Y2) == -1)
        {
            clear_exit_menu(ADMIN_EXIT_MENU_X1, ADMIN_EXIT_MENU_Y1, ADMIN_EXIT_MENU_X2, ADMIN_EXIT_MENU_Y2);
            return 1;
        }
    }
}

void AdminswitchPage()
{
    int i, j, k;
    setfillstyle(SOLID_FILL, MY_LIGHTBLUE);
    for (i = 0; i < 16; i++)
        for (j = 0; j < 12; j++)
            for (k = 0; k <= 5; k++)
            {
                bar(i * 40 + 20 - k * 4, j * 40 + 20 - k * 4, i * 40 + 20 + k * 4, j * 40 + 20 + k * 4);
                delay(1);
            }
}